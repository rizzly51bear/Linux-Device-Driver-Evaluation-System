# Linux Device Driver AI Evaluation System


---

## Table of Contents

- [ Project Overview](#project-overview)
- [ Features](#features)
- [ Getting Started](#getting-started)
  - [1. System Requirements & Prerequisites](#1-system-requirements--prerequisites)
  - [2. Initial Project Setup](#2-initial-project-setup)
  - [3. Prepare Your Python Environment](#3-prepare-your-python-environment)
- [ Running an Evaluation](#running-an-evaluation)
- [ Understanding and Browse Results](#understanding-and-browse-results)
- [ Scoring Rubric Explained](#scoring-rubric-explained)
- [ Scenarios Covered](#scenarios-covered)
- [ Identified Flaws & Future Work](#identified-flaws--future-work)
- [ Contributing](#contributing)
- [ License](#license)

---

##  Project Overview

This system automatically evaluates Linux kernel device drivers (AI-generated or human-written) by:

- Compiling them into `.ko` kernel object modules.
- Performing static analysis via `clang-tidy` and `checkpatch.pl`.
- Running functional load/unload tests using `insmod`, `rmmod`, and `dmesg`.
- Generating JSON-based evaluation reports with weighted scores.

Built entirely in Python, it helps benchmark the quality of AI-generated Linux kernel code in real-world scenarios.

---

##  Features

- Evaluate multiple drivers from a single file.
- Detects driver category (e.g., char device, ioctl, platform) based on filename.
- Generates and manages Makefiles for compilation.
- Runs kernel load/unload tests and parses `dmesg` logs.
- Produces detailed JSON reports with scoring breakdowns.
- Modular and extensible.

---

##  Getting Started

### 1. System Requirements & Prerequisites

- **OS**: Ubuntu or any Linux distribution with kernel headers installed.
- **Python**: 3.8 or higher
- **Tools Needed**:
  - `make`, `gcc`, `clang-tidy`
  - Linux kernel headers
  - `checkpatch.pl` (from Linux source tree)
  - `sudo` privileges for `insmod` / `rmmod`

---

### 2. Initial Project Setup

```
.
â”œâ”€â”€ evaluate_drivers.py
â”œâ”€â”€ drivers_to_evaluate/
â”‚   â””â”€â”€ ai_generated_drivers.txt
â”œâ”€â”€ eval_runs/
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ Makefile.template
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ checkpatch.pl
â””â”€â”€ README.md
```

---

### 3. Prepare Your Python Environment

```bash
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

If you donâ€™t have `checkpatch.pl`, copy it from a kernel source tree or download it.

---

##  Running an Evaluation

Use:

```bash
python3 evaluate_drivers.py
```

This will:

- Parse `ai_generated_drivers.txt` for drivers.
- Save each as a `.c` file in its own folder.
- Generate a `Makefile` for each driver.
- Compile the driver using `make`.
- Run `clang-tidy`, `checkpatch.pl`, and kernel tests.
- Store results in `eval_runs/YYYYMMDDTHHMMSS/results/<driver_name>/`

---

##  Understanding and Browse Results

Each evaluated driver gets:

- `report.json`: full evaluation data
- `char_rw.ko`: compiled module (if successful)
- `char_rw.c`: copied source file
- `char_rw.mod.c`: auto-generated by kernel build
- `make.log`, `clang_tidy.log`, `dmesg.log` (optional)

---

##  Scoring Rubric Explained

Total Score = **100**  
Weights are:

| Metric               | Weight     | Explanation |
|----------------------|------------|-------------|
| **Correctness**      | 40%        | - âœ… Compiles<br> - âœ… Loads/unloads without kernel OOPS<br> - âœ… Uses proper kernel APIs |
| **Security & Safety**| 30%        | - ğŸ” clang-tidy issues (`security-*`, `clang-analyzer-*`)<br> - âŒ Unsafe functions like `strcpy`, `sprintf` |
| **Code Quality**     | 20%        | - âœï¸ `checkpatch.pl` results<br> - ğŸ“‹ Code formatting and kernel style |
| **Creativity/Novelty**| 10%        | - ğŸ“¦ Use of advanced features: `procfs`, `ioctl`, `irq`, etc. |

All individual scores are calculated using a mix of binary (pass/fail) and normalized metrics.

---

## Scenarios Covered

This system evaluates these types of drivers:

1. `char_rw.c`: Basic character read/write.
2. `char_ioctl_sync.c`: Adds `ioctl` support.
3. `platform_gpio_irq.c`: Platform driver with interrupt handling.
4. `char_procfs.c`: Procfs interaction.
5. `hello_module.c`: Simple hello-world module.

Each has a specific rubric and test sequence.

---

##  Identified Flaws & Future Work

- **Printk Message Detection**: Fails when printk output is incomplete.
- **False Positives**: clang-tidy sometimes over-flags `linuxkernel-*`.
- **Static Tuning**: Scoring weights are static; can be improved.
- **Modularization**: Break into CLI-based Python modules with options.
